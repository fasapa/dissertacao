\chapter{Formalização}\label{chp:formalizacao}

Neste capítulo apresento, primeiramente, a implementação de átomos e permutações, pois ambas as formalizações seguintes compartilham da mesma implementação, seção \ref{sec:atomos-permutacao}, junto com duas formalizações, no assistente de provas Coq, baseadas nos trabalhos de Copello \textit{et. al.} \cite{Copello2016}, seção \ref{sec:copello}, e Choudhury \cite{Choudhury2015}, seção \ref{sec:choudhury}, ambos em Agda. A primeira formalização está relacionado a uma classe de implementações pragmáticas, também denominadas de ``técnicas nominais'' \cite{Copello2016,Copello2018,Ambal2020,Tasistro2015,Aydemir2007}, enquanto a segunda, pertence ao grupo de formalizações de conjuntos nominais, ou sintaxe abstrata nominal \cite{AyalaRincon2019,Choudhury2015}.

Inicialmente, optei pela técnica nominal adotada por Copello \textit{et. al.}, aonde as principais características são: considerar a permutação de nomes como uma operação básica, por exemplo ao definir substituição de termos ou $\alpha$-equivalência, pois esta apresenta um melhor comportamento, devido a impossibilidade da captura de variável livre, simplificando a verificação. Outro ponto importante, no trabalho de Copello, é a derivação de um princípio de indução/recursão $\alpha$-estrutural, simulando efetivamente a BVC.
Todavia, como verificado em minhas investigações e outros trabalhos \cite{Aydemir2008}, a falta de uma formalização da teoria nominal, ou uma biblioteca mecanizada/automatizada de infraestrutura, acarreta desenvolvimentos desagradáveis, focado em sistemas isolados, pois a adição de outros para análise, por exemplo no estudo de codificações, implicaria na repetição de código. Portanto, alterei o foco do projeto para a investigação da formalização de conjuntos nominais em Coq, apoiado no trabalho de Choudhury, como uma biblioteca de suporte, para projetos futuros.

% O conjunto dos pragmatistas veem operações baseadas em permutação de nomes como uma ``boa ideia''. Isto, se deve ao fato da permutação de nomes se comportar melhor do que a substituição, pois nesta pode ocorrer captura de variável livre, enquanto a permutação é livre deste problema. Entretanto, tais trabalhos, geralmente, ficam restritos a uma um único sistema, devido a falta de mecanização e automação. Urban \cite{Urban2008}

%Urban está no meio das duas escolas (compromisso).

\section{Átomos e Permutação}\label{sec:atomos-permutacao}
Definimos nomes como estruturas atômicas, ou seja, indivisíveis. A estrutura interna dos átomos é irrelevante, pois estamos interessados apenas em seus identificadores, assim como ponteiros em algumas linguagens de programação. No entanto, certas condições precisam ser satisfeitas: conjunto de nomes deve ser infinito, contável e com igualdade decidível. Dessa forma, é possível obter um nome novo (\textbf{fresco}) e decidir quando dois nomes são diferentes ou iguais, sob quaisquer circunstâncias.

Módulos e assinaturas do Coq, permitem definir estruturas de dados abstratas, ideal para implementação de átomos. Enquanto módulos são semelhantes a outras implementações em linguagens de programação convencionais, no sentindo de agrupar definições sobre um único nome, assinaturas tem origem na linguagem OCaML, na qual permitem: ocultar, limitar o acesso e visibilidade do conteúdo externo ao módulo. Abaixo segue a implementação de átomos através desta técnica:
\vspace*{.4em}\\
\begin{minipage}[t]{0.5\linewidth}
\begin{coqcode}
Module Type ATOMIC.
  Parameter t : Set.
  Axiom cnt : Countable t.
  Axiom dec : EqDecision t.
  Axiom inf : Infinite t.
End ATOMIC.
Notation name := Atom.t
\end{coqcode}
\end{minipage}
\hspace{-5em}
\begin{minipage}[t]{0.5\linewidth}
\begin{coqcode}
Module Atom : ATOMIC.
  Definition t := nat.
  Instance cnt : Countable t := nat_countable.
  Instance dec : EqDecision t := nat_eq_dec.
  Instance inf : Infinite t := nat_infinite.
End Atom.
\end{coqcode}
\end{minipage}
\vspace*{1em}\\
O módulo \coqinline{Atom} agrupa a definição de átomo \coqinline{t}, juntamente com suas propriedades, via classes de tipos: \coqinline{cnt}, \coqinline{dec} e \coqinline{inf}, respectivamente provas da contabilidade, decidibilidade e infinitude. Átomos são implementados como naturais, pois estes possuem as mesmas propriedades esperadas para átomos. Afim de ocultar a implementação, aplica-se a assinatura \coqinline{ATOMIC} ao módulo \coqinline{Atom}, definindo-o como um conjunto qualquer, pertencente ao universo \coqinline{Set}. Ao longo da formalização utilizo a palavra-chave \coqinline{name} como apelido para \coqinline{Atom.t}.
\fabricio{Dizer oq Countable, EqDecision e Infinite fazem exatamente?}

%Implementamos átomos como naturais.
%Assinaturas (tipo de módulos) têm duas utilidades: garantir que um módulo implementa corretamente alguma regra e esconder informação. Somente declarações presentes na assinatura podem ser acessadas externa ao módulo. Como não estamos omitindo nenhuma definição, estamos escondendo a implementação de átomo. portanto Atom.t é abstrato.
%À esquerda definimos um novo tipo de módulo, denominado \coqinline{ATOMIC}, com um tipo abstrato \coqinline{t}, com instâncias nas classes \coqinline{EqDecision}, igualdade decidível, e \coqinline{Infinite}.
%Construímos um novo tipo abstrato \coqinline{Atom.t} com igualdade decidível \coqinline{Atom.dec} e infinito \coqinline{Atom.inf} no qual chamamos de \coqinline{name}. \coqinline{nameset} conjunto finito de nomes representado por uma lista. \fabricio{Explicar as type classes EqDecision e Infinite, que propriedades elas agregram ao desenvolvimento. Por exemplo EqDecision dá acesso a \texttt{decide} a partir de uma proposição, enquanto Infinite da acesso a \texttt{fresh} para gerar uma átomo novo}.
%Countable dá acesso a função choice: dado uma prova $\exists x, P x$ obtemos um programa $\{x | P x\}$ tipo $\Sigma$. Eqdecision dá acesso a decide: relaciona uma relação a um procedimento decidível para esta relação. Infinite da acesso a fresh: dado um conjunto obtemos um novo que não pertence a este conjunto.

A representação de permutações, e função de transposição, não tem segredos, sendo bastante similar a definida no capítulo \fabricio{REFERENCIAL TEORICO}:
\begin{coqcode}
Notation perm := (list (name * name)).
Notation "⟨ a , b ⟩" := (@cons (name * name) (a,b) (@nil _)).
Definition swap '(a,b) : name → name :=
  λ c, if decide (a = c) then b else if decide (b = c) then a else c.
Definition swap_perm (p: perm): name → name :=
  λ a, foldl (λ x y, swap y x) a p.
Instance perm_equiv: Equiv perm :=
  λ p q, ∀ a, swap_perm p a = swap_perm q a.
Instance perm_equivalence: Equivalence perm_equiv. Proof. (* ... *) Qed.
\end{coqcode}
Além da representação autoexplicativa \coqinline{perm}, a notação \coqinline{⟨a,b⟩} é útil ao referenciar permutações com um único par de nomes.

Como discutido anteriormente (\fabricio{QUAL SEÇÃO?}), a representação de permutações não é única. Para isto defino uma relação de equivalência \coqinline{perm_equiv}, que iguala duas permutações se estas produzem o mesmo resultado sobre todos os nomes, com uma prova (\coqinline{perm_equivalence}) de que realmente é uma equivalência (reflexividade, simetria e transitividade).
\section{Copello \textit{et. al.}}\label{sec:copello}
O ponto central dos trabalhos de Copello \textit{et. al.} \cite{Copello2016,Copello2018} é a derivação de um princípio de indução/recursão $\alpha$-estrutural para o \lcalc~em uma teoria de tipos construtiva (Agda), sem a necessidade de uma representação para classe de $\alpha$-equivalência. Os únicos requisitos são: a existência da ação de permutação, sobre os termos do cálculo, e $\alpha$-equivalência definido via permutação de nomes.  Copello \textit{et. al.} observa que propriedades/funções, sobre a classe de $\alpha$-equivalência são invariantes para membros da mesma, denominado $\alpha$-compatibilidade (definição \ref{def:alpha-compatibilidade}). Dessa forma, ao aplicar uma propriedade, ou função, da classe, pode-se escolher um membro apropriado (via permutação de nomes), ou seja fresco, efetivamente simulando a BVC.
\begin{definicao}[$\alpha$-Compatibilidade]\label{def:alpha-compatibilidade}
Um predicado $P$, sobre os termos do \lcalc~é dito $\alpha$-compatível se, dados $M$ e $N$ $\alpha$-equivalentes, implica $\pred{P}{M} \leftrightarrow \pred{P}{N}$.
Uma função $F$, sobre os termos do \lcalc~é dito fortemente $\alpha$-compatível se, dados $M$ e $N$ $\alpha$-equivalentes, implica $F(M) = F(N)$.
\end{definicao}

Com isso é possível derivar um princípio de indução (\coqinline{term_aeq_rect}) $\alpha$-estrutural para propriedades $\alpha$-compatíveis (\coqinline{αCompat}):
\begin{coqcode}
Definition term_aeq_rect:
  ∀ P: Λ → Type, αCompat P →
    (∀ a, P 'a) →
    (∀ m n, P m → P n → P (m × n)) →
    {L & ∀ m a, a ∉ L → P m → P (\a ⋅ m)} →
    ∀ m, P m.
Proof. (* ... *) Qed.
\end{coqcode}
Para simplificação, omito a definição dos termos do \lcalc~(\coqinline{Λ}), representada pelas notações: \coqinline{'a} para variável, \coqinline{m × n} aplicação e \coqinline{\a ⋅ m} abstração. A definição \coqinline{term_aeq_rect} é bem similar ao princípio de indução na estrutura dos termos do \lcalc, com exceção do caso da abstração. A notação \coqinline{{a: A & T a}} introduz um tipo $\Sigma$, ou subconjunto, com \coqinline{T: A → Type}. Sua interpretação depende se estamos utilizando como princípio de indução ou recursão. No caso da indução, temos a garantia de que a variável ligada é suficientemente fresca para um conjunto de nomes \coqinline{L}. Já para recursão, ela permite escolher um nome diferente do conjunto, fornecido pelo usuário, em meio a recursão, como pode ser visto abaixo, no operador de recursão \coqinline{LIt}, que sempre produz funções fortemente $\alpha$-compatíveis (\coqinline{LItStrongCompat}):
\begin{coqcode}
Definition LIt {A: Type} (L: nameset) (l: Λ)
           (fvar: name → A) (fapp: A → A → A) (fabs: atom → A → A) : A :=
  term_aeq_rect (λ _, A) (λ _ _ _, id) hv (λ _ _, hp)
                (existT _ L (λ _ b _ r, fabs b r)) l.
Lemma LItStrongCompat {A} fvar fapp fabs L:
  αStrongCompat (@LIt A fvar fapp fabs L).
\end{coqcode}
Para utilizar o princípio é necessário definir as funções para cada construtor do \lcalc: \coqinline{fvar}, \coqinline{fapp} e \coqinline{fabs} e um conjunto \coqinline{L} de nomes a serem evitados. Por exemplo, a substituição de termos é definida como:
\begin{coqcode}
Definition subst_term (M N: Λ) (a: name): Λ :=
  let L := ({a} ∪ fv N ∪ fv M) in (* fv = support *)
  @LIt Λ (λ b, if decide (a = b) then N else 'b) App Abs L M.
Notation " '[' a ':=' N ']' M " := (subst_term M N a)
\end{coqcode}
No caso da abstração não é necessário verificar a captura de variável livre, pois temos a garantia de que as variáveis ligadas serão sempre diferentes do conjunto \coqinline{L}, portanto passamos como argumento seu construtor \coqinline{Abs}, para propagar a recursão ao corpo da abstração.

Infelizmente, a simplicidade aparente do método esconde alguns problemas. Algumas demonstrações tornam-se longas e complexas, com aplicações não triviais de transitividade, o que dificulta bastante a automação da técnica. Isto complica a aplicação em formalizações que contem mais de um sistema, acarretando em repetição de código. Apesar das limitações, o grande triunfo do método é poder utilizar a igualdade padrão do Coq, na permutação e maioria das provas, eliminando a necessidade de \setoids, simplificando aplicações de reescrita.

\section{Choudhury}\label{sec:choudhury}
O método de Copello, apesar de simples e direto, introduz repetição de código e complexidade com a introdução de novas estrutura a formalização. Uma possível solução é seria o desenvolvimento de uma biblioteca de conjuntos nominais, encapsulando e abstraindo conceitos, afim reduzir a reutilização de código e mecanizar a implementação de Copello.

Na busca de desenvolvimentos, e bibliotecas, de conjuntos nominais, em assistentes de provas, pouco foi encontrado, com exceção dos trabalhos produzidor por Urban e seu grupo de métodos nominais\footnote{\textit{Nominal Methods Group} \url{https://nms.kcl.ac.uk/christian.urban/Nominal/}} \cite{Urban2008,Urban2005,Urban2006,Huffman2010,Urban2011}, e a dissertação de mestrado de Choudhury, sob orientação de Pitts \cite{Choudhury2015}. Entretanto qualifico os trabalhos do Urban como formalizações das \textbf{técnicas} nominais, pois estão interessados apenas na aplicação das ideias centrais da teoria nominal em assistentes, assim como Copello. O que diferencia ambos os projetos é a aptidão de mecanização e automação do pacote nominal de Urban. Dessa busca, o único trabalho que realmente propunha formalizar a noção de conjuntos nominais foi Choudhury, com uma representação \textbf{construtiva} no assistente de provas Agda \cite{Bove2009}. É importante frisar o construtivo, pois na teoria nominal é incompatível em lógicas construtivas, isto se deve ao fato de o menor suporte finito ser não construtivo \cite{Swan2016,Swan2017}.

Meu desenvolvimento segue, basicamente, o trabalho de Choudhury, com algumas `. A principal é a forma, ou caminho, utilizado para formalizar conjuntos nominais. Choudhury opta por utilizar teoria de categorias, entretanto a falta de uma biblioteca robusta e livre de axiomas de categorias em Coq, impossibilitou seguir por este caminho\footnote{\fabricio{Falar pq? Problemas de inconsistencia de universos causado por categorias grandes?}}. Outros desvios propostos da representação de Choudhury, menos relevantes, serão introduzidos ao longo do capítulo.

\subsection{Ação de permutação}
Afim de garantir que a definição de permutações (seção \ref{sec:atomos-permutacao}) realmente implementa permutações, estabeleço uma instância de \coqinline{Group} (seção \ref{sec:classes-setoids}) para \coqinline{perm}, com a concatenação como operador binário, reversão de lista como função reversa e lista vazia como elemento neutro:
\begin{coqcode}
Instance perm_neutral: Neutral perm := @nil (name * name).
Instance perm_operator: Operator perm := @app (name * name).
Instance perm_inverse: Inverse perm := @reverse (name * name).
Instance PermGrp: Group perm. Proof. (* ... *) Qed.
\end{coqcode}

Para ação de permutação, desvio um pouco da metodologia de colocar classes operacionais como parâmetros implícitos generalizados na definição de classes predicados (seção \ref{sec:classes}), como pode ser visto na definição de ação de grupo:
\begin{coqcode*}{linenos=true}
Class Action A X := action: A → X → X.    Infix "•" := action.
Class GAction `(Group G) (X: Type) `{Act: Action G X, Equiv X}: Prop := {
   gact_setoid :> Equivalence(≡@{X});
   gact_proper :> Proper ((≡@{G}) ⇒ (≡@{X}) ⇒ (≡@{X})) (•);
   gact_id: ∀ (x: X), ɛ@{G} • x ≡@{X} x;
   gact_compat: ∀ (p q: G) (x: X), p • (q • x) ≡@{X} (q + p) • x
}.

Class PermAct X := prmact :> Action perm X.
Class Perm (X : Type) `{P : PermAct X, Equiv X} := 
   prmtype :> GAction PermGrp X (Act := @prmact X P).
\end{coqcode*}
Na linha 2, grupo é um parâmetro explícito generalizado \coqinline{`(Group G)}, ou seja, o parâmetro para uma instância de grupo é explícita, enquanto o resto dos parâmetros de grupo são introduzidos implicitamente. Isto tem um motivo semântico, pois é a de um grupo sobre uma tipo, e prático, em razão de que sempre teremos uma prova de grupo disponível no contexto ao trabalhar com alguma ação. As linhas 3 e 4 são permitem reescritas no contexto da ação, respeitando as equivalências de grupo (\coqinline{≡@{G}}) e do tipo que sofre a ação (\coqinline{≡@{X}}). Enquanto as linhas 5 e 6 são os lemas usuais de ação de grupo a esquerda. Linhas 9--11 especializo ação de grupo para ação de permutação. A classe \coqinline{Perm} é justamente a definição de tipos de permutação definido por Urban em \cite{Urban2008}.

\subsubsection{Permutação sobre funções}
Ao contrário de Urban, Choudhury não define nenhuma instância de tipos de permutação, portanto sigo a implementação do primeiro aqui para mostrar que existe uma instância de funções para \coqinline{Perm}. Instancias para nomes, listas e tuplas são trivialmente demonstráveis, entretanto para funções provou-se mais desafiador. Sem \textit{setoids} seria impossível definir tal instância sem adição do axioma da extensionalidade funcional, o que acarretaria numa formalização não construtiva. Entretanto o simples uso de \textit{setoids} também não garante o mesmo.



Assim como feito por Urban, é facilmente demonstrável que, nomes, listas e tuplas (\fabricio{pares?}) são instâncias de \coqinline{Perm}.

\fabricio{FUNÇÕES AÇÃO DE PERMUTAÇÃO}

\subsection{Conjuntos nominal}
\begin{coqcode}
Class Support A := support: A → nameset.
Class Nominal (X: Type) `{Spt : Support X, Perm X}: Prop := {
   nperm :> Perm X;
   support_spec: ∀ (x: X) (a b: name),
      a ∉ (support x) → b ∉ (support x) → ⟨a,b⟩ • x ≡@{X} x
}.
\end{coqcode}

Por que Perm é um membro de Nominal? Por que Nominal é um tipo de permutação na qual todo elemento é finitamente suportado.


   ao definirmos ação de permutação estou interessado em uma implementação de permutação. Em Haskell isso não seria um problema, pois instâncias são únicas para tipos. Como pode-se haver uma ou mais instâncias de \coqinline{}

A repetição de código para diferentes estruturas, devido ao método anterior de Copello, traz uma questão interessante sobre formalizar conjuntos nominais antes de aplicar seu método. Com uma biblioteca já fundamentada sobre conjuntos nominais boa parte seria reaproveitada para desenvolvimentos futuros, quem sabe até mecanizada. Porém a formalização de conjuntos nominais em lógicas construtivas apresentam seus próprios desafios. Aqui apresentamos o desenvolvimento de uma formalização de conjuntos nominais bem próxima a apresentada por Pritam. Com a diferença de aproveitarmos algums mecanismos presentes no Coq que possibilitam uma formalização mais simples, próxima ao desenvolvimento da metateoria por meios tradicionais. Pritam descreve dois desafios à esta formalização: a não construtividade do menor suporte finito e trabalhar com \setoids.

Não seria possível desenvolver a teoria, como nos trabalhos de Urban, livre de axiomas. Uma das noções centrais, funções são tipos de permutação, podem ser demonstrados apenas assumindo a extensionalidade funcional. É importante frisar que extensionalidade não é incompatível com a lógica do Coq, podendo ser incluída como axioma. Entretanto introduzimos um caráter não computacional a formalização, que posteriormente possa impossibilitar extração de código. Ainda, é importante notar que é possível trabalhar com os dois, extensionalidade e extração sem prejudicar, como é feito pela extensão Program do Coq, mas isto está fora do escopo deste trabalho. Portanto optamos por trabalhar com \setoids durante toda a formalização. O que nos diferencia de Pritam é a aplicação de tipos de classes e reescrita generalizada, para alcançar uma formalização mais simples, enxuta, similar as provas de papel e caneta para a metateoria.

Seguimos um modelo proposto por ... para definição das classes de tipos, sendo elas dividas em duas. As classes operacionais servem como referência as operações e notações utilizadas no segundo tipo de classe, fornecendo um nome canônico, uma forma de referenciar as operações. As classes predicados implementam as restrições da classe de tipo em específico, similarmente em Haskell. Um método denominado \textit{unbundle}.

Afim de mostrar que a permutação definida acima, implementa permutação mostramos que ela forma um grupo de permutação. Primeiro as classes de predicado e respectivas notações:

A definição \coqinline{Group} pode ser lido da seguinte forma: o tipo \coqinline{A} forma um grupo, se dado um elemento neutro, uma operação binária e uma opera unária inverso, ele satisfaz os axiomas padrão de grupo. Além disso queremos garantir que a relação seja uma equivalência, e que a operação binária e unária respeitem a equivalência (\coqinline{grp_op_proper} e \coqinline{grp_inv_proper}). Ao estabelecermos as propriedades Proper, indicamos ao Coq que é seguro fazer a reescrita no contexto das funções, desde que os termos reescritos sejam equivalentes. Dessa forma conseguimos demonstrar propriedades para as classes idênticas as provas tradicionais, simplificando a formalização: \fabricio{TALVES SEJA MAIS INTERESSANTE MOSTRAR UM LEMMA DE AÇÃO DE GRUPO}