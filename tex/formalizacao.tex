\chapter{Formalização}\label{chp:formalizacao}

Neste capítulo apresento, primeiramente, a implementação de átomos e permutações, pois ambas as formalizações seguintes compartilham da mesma implementação, seção \ref{sec:atomos-permutacao}, junto com duas formalizações, no assistente de provas Coq, baseadas nos trabalhos de Copello \textit{et. al.} \cite{Copello2016}, seção \ref{sec:copello}, e Choudhury \cite{Choudhury2015}, seção \ref{sec:choudhury}, ambos em Agda. A primeira formalização está relacionado a uma classe de implementações pragmáticas, também denominadas de ``técnicas nominais'' \cite{Copello2016,Copello2018,Ambal2020,Tasistro2015,Aydemir2007}, enquanto a segunda, pertence ao grupo de formalizações de conjuntos nominais, ou sintaxe abstrata nominal \cite{AyalaRincon2019,Choudhury2015}.

Inicialmente, optei pela técnica nominal adotada por Copello \textit{et. al.}, aonde as principais características são: considerar a permutação de nomes como uma operação básica, por exemplo ao definir substituição de termos ou $\alpha$-equivalência, pois esta apresenta um melhor comportamento, devido a impossibilidade da captura de variável livre, simplificando a verificação. Outro ponto importante, no trabalho de Copello, é a derivação de um princípio de indução/recursão $\alpha$-estrutural, simulando efetivamente a BVC.
Todavia, como verificado em minhas investigações e outros trabalhos \cite{Aydemir2008}, a falta de uma formalização da teoria nominal, ou uma biblioteca mecanizada/automatizada de infraestrutura, acarreta desenvolvimentos desagradáveis, focado em sistemas isolados, pois a adição de outros para análise, por exemplo no estudo de codificações, implicaria na repetição de código. Portanto, alterei o foco do projeto para a investigação da formalização de conjuntos nominais em Coq, apoiado no trabalho de Choudhury, como uma biblioteca de suporte, para projetos futuros.

% O conjunto dos pragmatistas veem operações baseadas em permutação de nomes como uma ``boa ideia''. Isto, se deve ao fato da permutação de nomes se comportar melhor do que a substituição, pois nesta pode ocorrer captura de variável livre, enquanto a permutação é livre deste problema. Entretanto, tais trabalhos, geralmente, ficam restritos a uma um único sistema, devido a falta de mecanização e automação. Urban \cite{Urban2008}

%Urban está no meio das duas escolas (compromisso).

\section{Átomos e Permutação}\label{sec:atomos-permutacao}
Definimos nomes como estruturas atômicas, ou seja, indivisíveis. A estrutura interna dos átomos é irrelevante, pois estamos interessados apenas em seus identificadores, assim como ponteiros em algumas linguagens de programação. No entanto, certas condições precisam ser satisfeitas: conjunto de nomes deve ser infinito, contável e com igualdade decidível. Dessa forma, é possível obter um nome novo (\textbf{fresco}) e decidir quando dois nomes são diferentes ou iguais, sob quaisquer circunstâncias.

Módulos e assinaturas do Coq, permitem definir estruturas de dados abstratas, ideal para implementação de átomos. Enquanto módulos são semelhantes a outras implementações em linguagens de programação convencionais, no sentindo de agrupar definições sobre um único nome, assinaturas tem origem na linguagem OCaML, na qual permitem: ocultar, limitar o acesso e visibilidade do conteúdo externo ao módulo. Abaixo segue a implementação de átomos através desta técnica:
\vspace*{.4em}\\
\begin{minipage}[t]{0.5\linewidth}
\begin{coqcode}
Module Type ATOMIC.
  Parameter t : Set.
  Axiom cnt : Countable t.
  Axiom dec : EqDecision t.
  Axiom inf : Infinite t.
End ATOMIC.
Notation name := Atom.t
\end{coqcode}
\end{minipage}
\hspace{-5em}
\begin{minipage}[t]{0.5\linewidth}
\begin{coqcode}
Module Atom : ATOMIC.
  Definition t := nat.
  Instance cnt : Countable t := nat_countable.
  Instance dec : EqDecision t := nat_eq_dec.
  Instance inf : Infinite t := nat_infinite.
End Atom.
\end{coqcode}
\end{minipage}
\vspace*{1em}\\
O módulo \coqinline{Atom} agrupa a definição de átomo \coqinline{t}, juntamente com suas propriedades, via classes de tipos: \coqinline{cnt}, \coqinline{dec} e \coqinline{inf}, respectivamente provas da contabilidade, decidibilidade e infinitude. Átomos são implementados como naturais, pois estes possuem as mesmas propriedades esperadas para átomos. Afim de ocultar a implementação, aplica-se a assinatura \coqinline{ATOMIC} ao módulo \coqinline{Atom}, definindo-o como um conjunto qualquer, pertencente ao universo \coqinline{Set}. Ao longo da formalização utilizo a palavra-chave \coqinline{name} como apelido para \coqinline{Atom.t}.
\fabricio{Dizer oq Countable, EqDecision e Infinite fazem exatamente?}

%Implementamos átomos como naturais.
%Assinaturas (tipo de módulos) têm duas utilidades: garantir que um módulo implementa corretamente alguma regra e esconder informação. Somente declarações presentes na assinatura podem ser acessadas externa ao módulo. Como não estamos omitindo nenhuma definição, estamos escondendo a implementação de átomo. portanto Atom.t é abstrato.
%À esquerda definimos um novo tipo de módulo, denominado \coqinline{ATOMIC}, com um tipo abstrato \coqinline{t}, com instâncias nas classes \coqinline{EqDecision}, igualdade decidível, e \coqinline{Infinite}.
%Construímos um novo tipo abstrato \coqinline{Atom.t} com igualdade decidível \coqinline{Atom.dec} e infinito \coqinline{Atom.inf} no qual chamamos de \coqinline{name}. \coqinline{nameset} conjunto finito de nomes representado por uma lista. \fabricio{Explicar as type classes EqDecision e Infinite, que propriedades elas agregram ao desenvolvimento. Por exemplo EqDecision dá acesso a \texttt{decide} a partir de uma proposição, enquanto Infinite da acesso a \texttt{fresh} para gerar uma átomo novo}.
%Countable dá acesso a função choice: dado uma prova $\exists x, P x$ obtemos um programa $\{x | P x\}$ tipo $\Sigma$. Eqdecision dá acesso a decide: relaciona uma relação a um procedimento decidível para esta relação. Infinite da acesso a fresh: dado um conjunto obtemos um novo que não pertence a este conjunto.

A representação de permutações, e função de transposição, não tem segredos, sendo bastante similar a definida no capítulo \fabricio{REFERENCIAL TEORICO}:
\begin{coqcode}
Notation perm := (list (name * name)).
Notation "⟨ a , b ⟩" := (@cons (name * name) (a,b) (@nil _)).
Definition swap '(a,b) : name → name :=
  λ c, if decide (a = c) then b else if decide (b = c) then a else c.
Definition swap_perm (p: perm): name → name :=
  λ a, foldl (λ x y, swap y x) a p.
Instance perm_equiv: Equiv perm :=
  λ p q, ∀ a, swap_perm p a = swap_perm q a.
Instance perm_equivalence: Equivalence perm_equiv. Proof. (* ... *) Qed.
\end{coqcode}
Além da representação autoexplicativa \coqinline{perm}, a notação \coqinline{⟨a,b⟩} é útil ao referenciar permutações com um único par de nomes.

Como discutido anteriormente (\fabricio{QUAL SEÇÃO?}), a representação de permutações não é única. Para isto defino uma relação de equivalência \coqinline{perm_equiv}, que iguala duas permutações se estas produzem o mesmo resultado sobre todos os nomes, com uma prova (\coqinline{perm_equivalence}) de que realmente é uma equivalência (reflexividade, simetria e transitividade).
\section{Copello \textit{et. al.}}\label{sec:copello}
O ponto central dos trabalhos de Copello \textit{et. al.} \cite{Copello2016,Copello2018} é a derivação de um princípio de indução/recursão $\alpha$-estrutural para o \lcalc~em uma teoria de tipos construtiva (Agda), sem a necessidade de uma representação para classe de $\alpha$-equivalência. Os únicos requisitos são: a existência da ação de permutação, sobre os termos do cálculo, e $\alpha$-equivalência definido via permutação de nomes.  Copello \textit{et. al.} observa que propriedades/funções, sobre a classe de $\alpha$-equivalência são invariantes para membros da mesma, denominado $\alpha$-compatibilidade (definição \ref{def:alpha-compatibilidade}). Dessa forma, ao aplicar uma propriedade, ou função, da classe, pode-se escolher um membro apropriado (via permutação de nomes), ou seja fresco, efetivamente simulando a BVC.
\begin{definicao}[$\alpha$-Compatibilidade]\label{def:alpha-compatibilidade}
Um predicado $P$, sobre os termos do \lcalc~é dito $\alpha$-compatível se, dados $M$ e $N$ $\alpha$-equivalentes, implica $\pred{P}{M} \leftrightarrow \pred{P}{N}$.
Uma função $F$, sobre os termos do \lcalc~é dito fortemente $\alpha$-compatível se, dados $M$ e $N$ $\alpha$-equivalentes, implica $F(M) = F(N)$.
\end{definicao}

Com isso é possível derivar um princípio de indução (\coqinline{term_aeq_rect}) $\alpha$-estrutural para propriedades $\alpha$-compatíveis (\coqinline{αCompat}):
\begin{coqcode}
Definition term_aeq_rect:
  ∀ P: Λ → Type, αCompat P →
    (∀ a, P 'a) →
    (∀ m n, P m → P n → P (m × n)) →
    {L & ∀ m a, a ∉ L → P m → P (\a ⋅ m)} →
    ∀ m, P m.
Proof. (* ... *) Qed.
\end{coqcode}
Para simplificação, omito a definição dos termos do \lcalc~(\coqinline{Λ}), representada pelas notações: \coqinline{'a} para variável, \coqinline{m × n} aplicação e \coqinline{\a ⋅ m} abstração. A definição \coqinline{term_aeq_rect} é bem similar ao princípio de indução na estrutura dos termos do \lcalc, com exceção do caso da abstração. A notação \coqinline{{a: A & T a}} introduz um tipo $\Sigma$, ou subconjunto, com \coqinline{T: A → Type}. Sua interpretação depende se estamos utilizando como princípio de indução ou recursão. No caso da indução, temos a garantia de que a variável ligada é suficientemente fresca para um conjunto de nomes \coqinline{L}. Já para recursão, ela permite escolher um nome diferente do conjunto, fornecido pelo usuário, em meio a recursão, como pode ser visto abaixo, no operador de recursão \coqinline{LIt}, que sempre produz funções fortemente $\alpha$-compatíveis (\coqinline{LItStrongCompat}):
\begin{coqcode}
Definition LIt {A: Type} (L: nameset) (l: Λ)
           (fvar: name → A) (fapp: A → A → A) (fabs: atom → A → A) : A :=
  term_aeq_rect (λ _, A) (λ _ _ _, id) hv (λ _ _, hp)
                (existT _ L (λ _ b _ r, fabs b r)) l.
Lemma LItStrongCompat {A} fvar fapp fabs L:
  αStrongCompat (@LIt A fvar fapp fabs L).
\end{coqcode}
Para utilizar o princípio é necessário definir as funções para cada construtor do \lcalc: \coqinline{fvar}, \coqinline{fapp} e \coqinline{fabs} e um conjunto \coqinline{L} de nomes a serem evitados. Por exemplo, a substituição de termos é definida como:
\begin{coqcode}
Definition subst_term (M N: Λ) (a: name): Λ :=
  let L := ({a} ∪ fv N ∪ fv M) in (* fv = support *)
  @LIt Λ (λ b, if decide (a = b) then N else 'b) App Abs L M.
Notation " '[' a ':=' N ']' M " := (subst_term M N a)
\end{coqcode}
No caso da abstração não é necessário verificar a captura de variável livre, pois temos a garantia de que as variáveis ligadas serão sempre diferentes do conjunto \coqinline{L}, portanto passamos como argumento seu construtor \coqinline{Abs}, para propagar a recursão ao corpo da abstração.

Infelizmente, a simplicidade aparente do método esconde alguns problemas. Algumas demonstrações tornam-se longas e complexas, com aplicações não triviais de transitividade, o que dificulta bastante a automação da técnica. Isto complica a aplicação em formalizações que contem mais de um sistema, acarretando em repetição de código. Apesar das limitações, o grande triunfo do método é poder utilizar a igualdade padrão do Coq, na permutação e maioria das provas, eliminando a necessidade de \setoids, simplificando aplicações de reescrita.

\section{Choudhury}\label{sec:choudhury}
O método de Copello, apesar de simples e direto, introduz repetição de código e complexidade com a introdução de novas estrutura a formalização. Uma possível solução é seria o desenvolvimento de uma biblioteca de conjuntos nominais, encapsulando e abstraindo conceitos, afim reduzir a reutilização de código e mecanizar a implementação de Copello.

Na busca de desenvolvimentos, e bibliotecas, de conjuntos nominais, em assistentes de provas, pouco foi encontrado, com exceção dos trabalhos produzidor por Urban e seu grupo de métodos nominais\footnote{\textit{Nominal Methods Group} \url{https://nms.kcl.ac.uk/christian.urban/Nominal/}} \cite{Urban2008,Urban2005,Urban2006,Huffman2010,Urban2011}, e a dissertação de mestrado de Choudhury, sob orientação de Pitts \cite{Choudhury2015}. Entretanto qualifico os trabalhos do Urban como formalizações das \textbf{técnicas} nominais, pois estão interessados apenas na aplicação das ideias centrais da teoria nominal em assistentes, assim como Copello. O que diferencia ambos os projetos é a aptidão de mecanização e automação do pacote nominal de Urban. Dessa busca, o único trabalho que realmente propunha formalizar a noção de conjuntos nominais foi Choudhury, com uma representação \textbf{construtiva} no assistente de provas Agda \cite{Bove2009}. 

%É importante frisar o construtivo, pois na teoria nominal é incompatível em lógicas construtivas, isto se deve ao fato de o menor suporte finito ser não construtivo \cite{Swan2016,Swan2017}.

Meu desenvolvimento segue, basicamente, o trabalho de Choudhury, com algumas exceções. A principal é a fundamentação utilizada para formalizar conjuntos nominais. Choudhury opta por utilizar teoria de categorias, entretanto a falta de uma biblioteca robusta e livre de axiomas de categorias em Coq, impossibilitou seguir por este caminho\footnote{\fabricio{Falar pq? Problemas de inconsistencia de universos causado por categorias grandes?}}. Outros desvios propostos da representação de Choudhury, menos relevantes, serão introduzidos ao longo do capítulo.

\subsection{Ação de permutação}
Afim de garantir que a definição de permutações (seção \ref{sec:atomos-permutacao}) realmente implementa permutações, estabeleço uma instância de \coqinline{Group} (seção \ref{sec:classes-setoids}) para \coqinline{perm}, com a concatenação como operador binário, reversão de lista como função reversa e lista vazia como elemento neutro:
\begin{coqcode}
Instance perm_neutral: Neutral perm := @nil (name * name).
Instance perm_operator: Operator perm := @app (name * name).
Instance perm_inverse: Inverse perm := @reverse (name * name).
Instance PermGrp: Group perm. Proof. (* ... *) Qed.
\end{coqcode}

Para ação de permutação, desvio um pouco da metodologia de colocar classes operacionais como parâmetros implícitos generalizados na definição de classes predicados (seção \ref{sec:classes}), como pode ser visto na definição de ação de grupo:
\begin{coqcode*}{linenos=true}
Class Action A X := action: A → X → X.    Infix "•" := action.
Class GAction `(Group G) (X: Type) `{Act: Action G X, Equiv X}: Prop := {
   gact_setoid :> Equivalence(≡@{X});
   gact_proper :> Proper ((≡@{G}) ⇒ (≡@{X}) ⇒ (≡@{X})) (•);
   gact_id: ∀ (x: X), ɛ@{G} • x ≡@{X} x;
   gact_compat: ∀ (p q: G) (x: X), p • (q • x) ≡@{X} (q + p) • x
}.

Class PermAct X := prmact :> Action perm X.
Class Perm (X : Type) `{P : PermAct X, Equiv X} := 
   prmtype :> GAction PermGrp X (Act := @prmact X P).
\end{coqcode*}
Na linha 2, grupo é um parâmetro explícito generalizado \coqinline{`(Group G)}, ou seja, o parâmetro para uma instância de grupo é explícita, enquanto o resto dos parâmetros de grupo são introduzidos implicitamente. Isto tem um motivo semântico, pois é a de um grupo sobre uma tipo, e prático, em razão de que sempre teremos uma prova de grupo disponível no contexto ao trabalhar com alguma ação. As linhas 3 e 4 são permitem reescritas no contexto da ação, respeitando as equivalências de grupo (\coqinline{≡@{G}}) e do tipo que sofre a ação (\coqinline{≡@{X}}). Enquanto as linhas 5 e 6 são os lemas usuais de ação de grupo a esquerda. Linhas 9--11 especializo ação de grupo para ação de permutação. A classe \coqinline{Perm} é justamente a definição de tipos de permutação definido por Urban em \cite{Urban2008}.

%\subsubsection{Permutação sobre funções}
%Instancias para nomes, listas e tuplas (pares) para \coqinline{Perm} são trivialmente demonstráveis, entretanto, funções prova-se mais desafiador. Choudhury percorre um caminho mais longo, entretanto viável quando um arcabouço de categorias está disponível, tratando funções como pares ordenados (tuplas) e definindo operadores de \textit{curry} e \textit{uncurry}. Aqui, opto pelo caminho direto, semelhante a Urban, definindo \coqinline{Perm (A → B)} ao invés de \coqinline{Perm (A , B)}. Entretanto, diferentemente a Urban, sem o uso \textit{setoids} seria impossível definir tal instância sem adição do axioma da extensionalidade funcional, o que acarretaria numa formalização não construtiva.
%
%Infelizmente, utilizar \textit{setoids} não é suficiente para definir \coqinline{Perm (A → B)}. É necessário garantir que a função em sí seja respeitosa. Dados $A$ e $B$ tipos de permutação (\coqinline{Perm A} e \coqinline{Perm B}), queremos mostrar que $A \rightarrow B$ também é um tipo de permutação, ou seja, definir uma instância para \coqinline{Perm (A → B)}. Primeiramente, define-se a seguinte relação de equivalência e ação para funções: 
%\begin{coqcode}
%Instance perm_fun_equiv: Equiv (A → B) := 
%   λ f g, ∀ (a : A), f a ≡@{B} g a.
%Instance perm_fun_act: PermAct (A → B) :=
%   λ p (f : A → B), (λ (a : A), p • f(-p • a)).
%\end{coqcode}
%Isto é, duas funções são equivalentes, se estas produzem o mesmo resultado para todas as entradas. As propriedades \coqinline{gact_setoid}, \coqinline{gact_id} e \coqinline{gact_compat} de \coqinline{Perm} são trivialmente finalizadas. Entretanto, no caso de
%\coqinline{gact_proper} alcança-se o seguinte estado de prova:
%\begin{coqcode}
%∀ (a: A) (p q: perm) (f g: A → B),
%   x ≡ y → f ≡ g → p • f (-p • a) ≡@{B} q • g (-q • a)
%\end{coqcode}
%Como ação (\coqinline{•}) é respeitosa, obtem-se, aplicando as equivalências \coqinline{x ≡ y} e \coqinline{f ≡ g}:
%\begin{coqcode}
%∀ (a: A) (p q: perm) (f g: A → B),
%   x ≡ y → f ≡ g → p • f (-p • a) ≡@{B} p • f (-q • a)
%\end{coqcode}
%Entretanto, não tem-se uma prova de que \coqinline{f} e \coqinline{g} sejam respeitosas, impedindo a reescrita no argumentos de ambas, que levaria ao estado (sabendo que inversa é respeitosa): 
%\begin{coqcode}
%∀ (a: A) (p q: perm) (f g: A → B),
%   x ≡ y → f ≡ g → p • f (-p • a) ≡@{B} p • f (-p • a)
%\end{coqcode}
%Finalizável trivialmente por reflexividade.
%
%Então, é necessário introduzir uma restrição ao conjunto de funções, àquelas respeitosas. Para isso, sigo uma metodologia similar a (\fabricio{BIBLIOTECA STDPP DO IRIS}), definindo o tipo de funções respeitosas (\coqinline{proper_perm_fun}), isto é, um registro com uma função e uma prova de sua \fabricio{respeitosidade?}, junto com um conjunto de notações, afim de facilitar trabalhar com as mesmas:
%\begin{coqcode}
%Record proper_perm_fun: Type := ProperPermFun {
%   f_car :> A → B;
%   f_proper: Proper ((≡@{A}) ⇒ (≡@{B})) f_car
%}.
%Notation "'λp' x .. y , t" := (* ... *).
%Notation " A ⭌ B " := (proper_perm_fun A B).
%\end{coqcode}
%\fabricio{ENCONTRAR UM SÍMBOLO PARA FUNÇÃO RESPEITOSA} 
%O símbolo \coqinline{:>} em \coqinline{f_car} introduz uma coerção automática de \coqinline{proper_perm_fun} para função, ao se deparar com uma função respeitosa aonde esperava uma função normal. Com essas modificações é possível demonstrar que o conjunto de funções respeitosas são um tipo de permutação:
%\begin{coqcode}
%Instance perm_fun_proper_act : PermAct (A ⭌ B) :=
%   λ p (f : A ⭌ B), (λp (a : A), p • f(-p • a)).
%Instance perm_fun_proper_perm: Perm (A ⭌ B).
%\end{coqcode}

\subsection{Conjuntos nominal}
Conjuntos nominais são conjuntos de permutação na qual todos os membros são suportados. Por isso, a classe \coqinline{Nominal} definida abaixo, é uma simples extensão de \coqinline{Perm}, indicado pela propriedade \coqinline{nperm}:
\begin{coqcode}
Context (X: Type) `{Perm X}.
Class Support A := support: A → nameset.
Class Nominal `{Support X}: Prop := {
   nperm :> Perm X;
   support_spec: ∀ (x: X) (a b: name),
      a ∉ (support x) → b ∉ (support x) → ⟨a,b⟩ • x ≡@{X} x
}.
\end{coqcode}
Diferentemente de \coqinline{Group} e \coqinline{GAction}, a classe \coqinline{Nominal} é definida utilizando o mecanismo de seção e contexto do Coq. Através do vernacular \coqinline{Context}, Coq introduz ao contexto da definição o tipo \coqinline{X} e uma prova de que é um conjunto de permutação. Isso nos dá acesso a ação e relação de equivalência, definida por \coqinline{Perm X} e utilizada em \coqinline{support_spec}. Ao encerrar a seção, o assistente inclui, como argumentos implícitos à classe \coqinline{Nominal}, todos as propriedades e classes empregues na definição.
Outra alternativa de especificação seria: \coqinline{Class Nominal (X: Type) `{Support X, Perm X}: Prop := {(* ... *)}}, entretanto estaríamos introduzindo uma redundância de \coqinline{Pemr X} desnecessária, e semanticamente não faria sentindo, apesar de não afetar provas posteriores. É um fenômeno semelhante a herança e composição em linguagens orientadas a objetos. \coqinline{Perm} como argumento designaria ``composição'' de classes, e como membro de classe aponta para herança. Como a semântica correta é no sentido de herança, definimos desta maneira.

\subsubsection{Instâncias de conjuntos nominais e permutação}
Tendo definido a classe nominal, podemos começar a mostrar algumas instâncias triviais da mesma. Para mostrar que uma instância nominal para um tipo qualquer \coqinline{X}, seguimos os seguintes passos: (1) definir uma relação de equivalência para \coqinline{X}, ou seja, mostrar instâncias \coqinline{eqX: Equiv X} e \coqinline{Equivalence eqX}; (2) estipular uma ação de permutação \coqinline{PermAct X} com uma prova de que respeita as propriedades da mesma \coqinline{Perm X}; (3) definir suporte (\coqinline{Support X}) e finalmente mostrar que todo elemento é suportado (\coqinline{Nominal X}). A seguir apresento algumas instâncias interessantes de conjuntos nominais e conjuntos de permutação.

\begin{description}
	\item [Bool] é trivialmente nominal, com igualdade sintática como equivalência, ação e suporte vazios (o elemento sintático ``\coqinline{_}'' indica, ao Coq, que o parâmetro não será utilizado.):
	\begin{coqcode}
Instance bool_equiv: Equiv bool := λ b1 b2, b1 = b2.
Instance bool_act: Action bool := λ _ b, b.
Instance bool_perm: Perm bool. Proof. (* ... *) Qed.
Instance bool_supp: Support bool := ∅.
Instance bool_nom: Nominal bool. Proof. (* ... *) Qed.
	\end{coqcode}
	
	\item[Pares (ou tuplas)] são representados pela sintáxe: \coqinline{(a,b)} com \coqinline{a} e \coqinline{b} dois tipos quaisquer. As funções \coqinline{fst} e \coqinline{snd} extraem, respectivamente, o primeiro e segundo elemento do par. Dois pares são equivalentes, quando seus elementos são equivalentes:
	\begin{coqcode}
Instance pair_equiv `{Equiv X, Equiv Y}: Equiv (X * Y) :=
   λ '(x1,y1) '(x2,y2), (x1 ≡@{X} x2) ∧ (y1 ≡@{Y} y2).
	\end{coqcode}
	Ação sobre um par é a propagação da mesma para seus membros:
	\begin{coqcode}
Instance pair_act `{Action X, Action Y}: Action (X * Y) :=
   λ (p: perm) '(x,y), (p • x, p • y).
	\end{coqcode}
	Tendo definido equivalência e ação, podemos mostrar que par é um conjunto de permutação sabendo que seus membros também são:
	\begin{coqcode}
Instance pair_perm `{Perm X, Perm Y}: Perm (X * Y).
Proof. (* ... *) Qed.
	\end{coqcode}
	Suporte é a união dos suportes dos membros:
	\begin{coqcode}
Instance pair_supp `{Support X, Support Y}: Support (X * Y) :=
   λ '(x,y), (support x) ∪ (support y)
	\end{coqcode}
	E finalmente, assim como \coqinline{Perm}, mostramos que par é um conjunto nominal, desde que seus membros também sejam:
	\begin{coqcode}
Instance pair_nom `{Nominal X, Nominal Y}: Nominal (X * Y).
Proof. (* ... *) Qed.	
	\end{coqcode}

	\item[Funções] é mais problemática que os exemplos anteriores. Vamos somente demonstrar que funções formam um conjunto de permutação, se sua imagem e domínio também forem conjuntos de permutação. Isso introduz duas complicações: primeiro, não podemos utilizar igualdade sintática como relação, pois seria necessário assumir a extensionalidade funcional e segundo, temos que garantir tais funções respeitem as equivalência de seus domínios e imagens. A seguinte definição é errônea pois engloba o conjunto de todas as funções, respeitosas ou não:
	\begin{coqcode}
Instance perm_fun `{Perm X, Perm Y}: Perm (X → Y).
	\end{coqcode}
	Para contornar este problema, precisamos definir o subconjunto de funções respeitosas. Utilizo uma solução proposta na biblioteca Iris, um \textit{framework} de verificação de programas concorrentes através de lógica de separação \cite{Jung2015,Jung2016}. Definimos um registro que contem uma função (\coqinline{f_car}) associado a um certificado de respeitosa (\coqinline{f_proper}):
	\begin{coqcode}
Context (A B: Type) `{Perm A, Perm B}.
Record proper_perm_fun: Type := ProperPermFun {
   f_car :> A → B;
   f_proper: Proper ⇝ ((≡@{A}) ⇒ (≡@{B})) f_car
}.
Notation "A ⇝ B" := (proper_perm_fun A B).
Notation "'λp' x .. y , t" := (* ... *)
	\end{coqcode}
	O símbolo \coqinline{:>} (em \coqinline{f_car}) e as notações fornecem uma camada de abstração a definição, permitindo manusear \coqinline{proper_perm_fun} como uma função padrão do Coq. A partir daqui, temos tudo que precisamos, então seguimos o roteiro descrito no início da seção. Definimos uma equivalência computacional para a função carregada \coqinline{f_car}:
	\begin{coqcode}
Instance perm_fun_proper_equiv `{Equiv B}: Equiv (A ⇝ B) := 
   λ f g, ∀ (a: A), f a ≡@{B} g a.
	\end{coqcode}
	Seguido da ação sobre funções respeitosas:
	\begin{coqcode}
Instance perm_fun_proper_act `{PermAct A, PermAct B}: PermAct (A ⇝ B) :=
   λ r (f : A ⇝ B), (λp (a: A), r • f(-r • a)).
Proof. (* ... *) Qed.
	\end{coqcode}
	Note que estamos definindo ação sobre funções respeitosas, veja o símbolo \coqinline{λp}. Note também a necessidade de chamar o ambiente de provas, por meio do vernacular \coqinline{Proof. (* ... *) Qed}, pois precisamos garantir que esta definição de ação seja respeitosa. Finalizamos com a prova de que o conjunto de funções respeitosas são um conjunto de permutação:
	\begin{coqcode}
Instance perm_fun_proper_perm `{Perm A, Perm B}: Perm (A ⇝ B).
Proof. (* ... *) Qed.
	\end{coqcode}
\end{description}
