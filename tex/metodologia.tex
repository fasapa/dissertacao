\chapter{Metodologia}\label{chp:metodologia}

\section{Coq}
O assistente de provas Coq \cite{Coq2021} é sistema gerenciador de desenvolvimentos formais, composto por um motor de provas e três linguagens: Gallina (especificação), Vernacular (comandos) e Ltac (metaprogramação). O vernacular são comandos que permitem interagir com o ambiente de provas, como adicionar definições, realizar consultas e alterar configurações. Ltac é utilizado para metaprogramação, sendo principalmente utilizada no desenvolvimento de táticas, consumidas pelo motor de provas, e automação. Por último, Gallina uma linguagem funcional (especificação) com tipos dependentes, na qual implementa o Cálculo de Construções (Co)Indutivas \cite{Coquand1988,Coquand1990,PaulinMohring1993}. Para o desenvolvimento de provas, atendendo ao isomorfismo de Curry-Howard \cite{Soerensen2006}, Coq usufrui do motor de provas para construir termos Gallina (programas), interativamente, por meio da aplicação de táticas. Ao final, o termo construído é enviado ao kernel do Coq para verificação. A seguir, destaco alguns tópicos mais relevantes ao desenvolvimento.

\section{Igualdade e Setoids}
A igualdade padrão do Coq é sintática, definida pelo tipo indutivo \coqinline{eq} e representado pelo símbolo ``='':
\begin{coqcode}
Inductive eq (A: Type) (x: A): A → Prop := eq_refl: x = x.	
\end{coqcode}
O código acima, define uma família de igualdades para o tipo \coqinline{A}. A única forma de construir uma prova \coqinline{a = b}, é através do construtor \coqinline{eq_refl}, desde que \coqinline{a} e \coqinline{b} sejam iguais sintaticamente, ou convertíveis. Esta definição é bem útil para reescrita, como pode ser visto no princípio de indução/recursão gerado para \coqinline{eq}:
\begin{coqcode}
eq_rect: ∀ (A: Type) (x: A) (P: A -> Type), P x -> ∀ y: A, x = y -> P y.
\end{coqcode}
a função \coqinline{eq_rect} permite reescrever termos, em qualquer contexto \coqinline{P}, desde que sejam iguais. Em alguns casos, termos sintaticamente diferentes, ou não convertíveis, podem representar semanticamente o mesmo objeto (por exemplo, termos $\alpha$-equivalentes), mediante uma relação de equivalência. Isto implica na impossibilita a aplicação das táticas padrões de reescrita, para termos equivalentes. Uma solução seria definir conjuntos quocientes, entretanto isto não é possível sem a adição de axiomas \cite{Chicli2003}, pois tornaria o algoritmo de checagem de tipos indecidível \cite{Geuvers2002}. A alternativa é utilizar reescrita \setoid. % por intermédio de funções próprias (\fabricio{próxima seção}).

\textit{Setoids}, também conhecidos como conjuntos de Bishop \cite{Barthe2003,Bishop2012}, são estruturas formadas por um tipo equipado com uma relação de equivalência. São geralmente utilizados para codificar a ``ideia'' de conjuntos quocientes. Entretanto introduzem mais problemas do que soluções, um cenário conhecido como ``setoid hell''. A implementação de tipos \textit{setoid} não é abstrata, então o usuário, na prática, tem que lidar constantemente com detalhes da implementação (\textit{boilerplate}), como fazer o \textit{lift} do tipo para estrutura \textit{setoid} e gerenciamento manual da aplicação de provas de compatibilidade e lemas customizados de substituição, sem falar quando há mais de um \textit{setoid} envolvido. Isso tudo torna vida do usuário um inferno. Para mitigar algumas dessas deficiências, Coq \cite{Sozeau2009} possui uma implementação de reescrita generalizada (também conhecida como reescrita \textit{setoid}), o que permite substituir termos equivalentes através de uma interface limpa e simplificada, em muitos casos transparente. Para tanto, o usuário precisa informar ao sistema quais contextos (em outras palavras: funções), a reescrita é segura, isto é, demonstrando que a função é respeitosa (\textit{respectful}, veja definição \ref{def:proper}), por meio de instâncias da classe de tipos \coqinline{Proper}.
\begin{definicao}[Função Respeitosa]\label{def:proper}
	Sejam $X$ e $Y$ tipos, com suas respectivas relações de equivalências $\approx_X$ e $\approx_Y$. Uma função $F: X \rightarrow Y$ é própria, se esta preserva as relações de equivalência, para todas as entradas:
	\begin{equation*}
		\forall a b \in X, a \approx_X b \rightarrow F(a) \approx_Y F(b)
	\end{equation*}
\end{definicao}

\section{Classes de tipos}

Igualdade do coq e setoids

Classes de tipos


Teoria de tipos dependentes.

Termos convertíveis são iguais no Coq. Tipo indutivo eq. ``='' é a igualdade padrão no Coq ``$\equiv$'' igualdade \textit{setoid}. Pode-se substituir termos iguais em qualquer expressão pois eles são convertíveis (igualdade de Leibniz).
Mas ao introduzir uma noção diferente de equivalência, aonde termos não convertíveis são equivalentes, limitamos a reescrita
apenas somente a subtermos que são argumentos de funções que respeitam a equivalência, chamadas de funções próprias em relação a equivalência. A igualdade é ``forte'' demais, em alguns casos temos objetos que são conceitualmente iguais, mas sintaticamente diferentes. A igualdade no Coq é sintática. Coq não tem tipos quocientes (e não é uma boa ideia implementar PROCURAR REFERÊNCIA checagem de tipos indecidível), utiliza-se \textit{setoids} (conjuntos de Bishop). A substituição de subtermos equivalentes é chamado de reescrita de setoids, e é necessário o gerenciamento correto da aplicação de lemas próprios de funções e equivalências. Sem uma infraestrutura adequada as provas começam a ficar incontroláveis e grandes, aonde surge o setoid hell. Coq possui um mecanismo que da suporte a reescrita setoid baseado em classes de tipos.


Falar sobre classes de tipos. É semelhante a implementação em Haskell (falar pq isso é legal tipos de classes), mas no Coq são cidadões de primeira classe graças a teoria de tipos dependentes. Classes são implementadas como records (registros) aliado a tipos implícitos e busca de provas. Registros em Coq são dependentes, ou seja, um membro do registro pode referenciar um membro anterior. Instâncias das classes são instâncias ordinárias dos registros, mas cada instância é registrada em um banco de dados de ``sugestões'' para a busca de provas (semelhante ao Haskell), entretanto Coq permite mais de uma instância de classe (contrário do Haskell), pois pode-se ter mais de uma instância de um registro.

DIFERENÇA ENTRE SET E PROP. FALAR REESCRITA GENERALIZADA E TIPOS DE CLASSES.
\section{Setoids}